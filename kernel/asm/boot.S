/* boot.s
 * Assembler startup file for the STM32
 * Ford Seidel  2019-01-31
 * Ronit Banerjee
 */

# The Cortex M4 is a thumb only processor
.cpu cortex-m4
.syntax unified
.section .ivt
.thumb

.global ivt
ivt:
@ TODO: add the stack and the reset handler addr here.
.word   __msp_stack_top     /* stack top address */
.word   _reset_             /* 1 Reset */
.word   _nmi_               /* 2 NMI */
.word   _hard_fault_        /* 3 Hard Fault */
.word   _mm_fault_          /* 4 MM Fault */
.word   _bus_fault_         /* 5 Bus Fault */
.word   _usage_fault_       /* 6 Usage Fault */
.word   spin                /* 7 RESERVED */
.word   spin                /* 8 RESERVED */
.word   spin                /* 9 RESERVED*/
.word   spin                /* 10 RESERVED */
.word   _svc_asm_handler_   /* 11 SV call (SVC Instruction) */
.word   spin                /* 12 Debug reserved */
.word   spin                /* 13 RESERVED */
.word   _pend_sv_           /* 14 PendSV */
.word   systick_c_handler   /* 15 SysTick */
.word   spin                /* 16 IRQ0 Window Watchdog Interrupt */
.word   spin                /* 17 IRQ1 PVD */
.word   spin                /* 18 IRQ2 TAMPER */
.word   spin                /* 19 IRQ3 RTC   */
.word   spin                /* 20 IRQ4 FLASH   */
.word   spin                /* 21 IRQ5 RCC */
.word   spin                /* 22 IRQ6 EXTI0 */
.word   spin                /* 23 IRQ7 EXTI1  */
.word   spin                /* 24 IRQ8 EXTI2   */
.word   spin                /* 25 IRQ9 EXTI3 */
.word   spin                /* 26 IRQ10 EXTI4 */
.word   spin                /* 27 IRQ11 DMA1_Channel1   */
.word   spin                /* 28 IRQ12 DMA1_Channel2   */
.word   spin                /* 29 IRQ13 DMA1_Channel3 */
.word   spin                /* 30 IRQ14 DMA1_Channel4 */
.word   spin                /* 31 IRQ15 DMA1_Channel5   */
.word   spin                /* 32 IRQ16 DMA1_Channel6   */
.word   spin                /* 33 IRQ17 DMA1_Channel7 */
.word   spin                /* 34 IRQ18 ADC1_2 */
.word   spin                /* 35 IRQ19 CAN1_TX   */
.word   spin                /* 36 IRQ20 CAN1_TX0   */
.word   spin                /* 37 IRQ21 CAN1_RX1 */
.word   spin                /* 38 IRQ22 CAN1_SCE */
.word   spin                /* 39 IRQ23 EXTI9_5   */
.word   spin                /* 40 IRQ24 TIM1_BRK   */
.word   spin                /* 41 IRQ25 TIM1_UP */
.word   spin                /* 42 IRQ26 TIM1_TRG_COM */
.word   spin                /* 43 IRQ27 TIM1_CC   */
.word   spin                /* 44 IRQ28 TIM2   */
.word   spin                /* 45 IRQ29 TIM3 */
.word   spin                /* 46 IRQ30 TIM5 */
.word   spin                /* 47 IRQ31 I2C1_EV   */
.word   spin                /* 48 IRQ32 I2C1_ER   */
.word   spin                /* 49 IRQ33 I2C2_EV */
.word   spin                /* 50 IRQ34 I2C2_ER */
.word   spin                /* 51 IRQ35 SPI1   */
.word   spin                /* 52 IRQ36 SPI2   */
.word   spin                /* 53 IRQ37 USART1 */
.word   uart_irq_handler    /* 54 IRQ38 USART2 */
.word   spin                /* 55 IRQ39 USART3   */
.word   spin                /* 56 IRQ40 EXTI15_10   */
.word   spin                /* 57 IRQ41 RTCAlarm */
.word   spin                /* 58 IRQ42 OTG_FS_WKUP */
.word   spin                /* 59 IRQ43 RESERVED   */
.word   spin                /* 60 IRQ44 RESERVED   */
.word   spin                /* 61 IRQ45 RESERVED */
.word   spin                /* 62 IRQ46 RESERVED */
.word   spin                /* 63 IRQ47 RESERVED   */
.word   spin                /* 64 IRQ48 RESERVED   */
.word   spin                /* 65 IRQ49 RESERVED */
.word   spin                /* 66 IRQ50 TIM5 */
.word   spin                /* 67 IRQ51 SPI3   */
.word   spin                /* 68 IRQ52 UART4   */
.word   spin                /* 69 IRQ53 UART5 */
.word   spin                /* 70 IRQ54 TIM6 */
.word   spin                /* 71 IRQ55 TIM7   */
.word   spin                /* 72 IRQ56 DMA2_Channel1   */
.word   spin                /* 73 IRQ57 DMA2_Channel2 */
.word   spin                /* 74 IRQ58 DMA2_Channel3 */
.word   spin                /* 75 IRQ59 DMA2_Channel4   */
.word   spin                /* 76 IRQ60 DMA2_Channel5   */
.word   spin                /* 77 IRQ61 ETH */
.word   spin                /* 78 IRQ62 ETH_WKUP */
.word   spin                /* 79 IRQ63 CAN2_TX   */
.word   spin                /* 80 IRQ64 CAN2_RX0  */
.word   spin                /* 81 IRQ65 CAN2_RX1 */
.word   spin                /* 82 IRQ66 CAN2_SCE */
.word   spin                /* 83 IRQ67 OTG_FS   */

.section .text

.thumb_func
spin:
  bkpt

.thumb_func
_nmi_ :
  bkpt

.thumb_func
_hard_fault_ :
  bkpt

.thumb_func
_mm_fault_:
  bkpt

.thumb_func
_bus_fault_ : 
  bkpt

.thumb_func
_usage_fault_ : 
  bkpt

.thumb_func
_pend_sv_ :
  bkpt

.thumb_func
_spi1_handler:
  bkpt

.thumb_func
.global _reset_
_reset_:
  LDR r3, =_erodata
  LDR r4, =_k_data
  LDR r5, =_data_size
  CMP r5, r0
  BEQ .loadbss
  ADD r5, r5, r3 
.loadVariables:	
	LDR r8, [r3] 
	STR r8, [r4] 
        ADD r3, r3, #1  
	ADD r4, r4, #1 
	CMP r3, r5 
	BLT .loadVariables
.loadbss:
  LDR r6, =_bss_start 
  LDR r7, =_bss_size
  CMP r7, r0 
	BEQ .branch	
	ADD r7, r7, r6
.clearbss:
	STR r0, [r6]
	ADD r6, r6, #1
	CMP r6, r7
	BLT .clearbss 
.branch:  
	bl kernel_main
  

.thumb_func
.global _sys_tick_asm_
_sys_tick_asm_:
  bkpt

/* This assembly function is going to be the first part of our SVC handler. The
assembly function portion is responsible for copying the PSP value into a
register like r0. We need to do this step in assembly because we don't have
access to the special instruction needed to do this from C. I.e., the MRS
instruction is used to copy the value from a special purpose register (like PSP)
to a general purpose register (like r0).

Actually, if you have a compiler that supports CMSIS, then there are actually C
functions that, when encountered by the compiler, will generate these MRS and
MSR instructions as needed to access certain special purpose registers like PSP
and MSP. For example, on page 57 of the m4 generic manual, there is a function
"__get_PSP()" that will allow you to read the PSP into a general purpose
register under the hood. If you use that, then you wouldn't need this assembly
handler and could just do it in C.
*/
.thumb_func
.global _svc_asm_handler_
_svc_asm_handler_:
  /* Write the value of the PSP in r0, and then branch to the C-portion of the
  SVC handler. PSP's value is going to be the address of the item most recently
  pushed to the stack == the address of the top of the stack.
  NOTE: By placing this value in r0, we are quite simply following the ARM
  Architecture  Procedure Calling Standard (AAPCS) for the Armv7-m ISA that our
  Cortex M4 implements.

  That is, in this assembly function, we are calling a function (svc_c_handler)
  and placing the single argument for that function in r0--which is what the
  AAPCS calling convention tells us to do. Then, the assembly that gets
  generated for our C function will also follow that convention/protocol and
  know to look in r0 for the first argument. Standards are cool.
  */
  MRS r0, PSP
  b svc_c_handler